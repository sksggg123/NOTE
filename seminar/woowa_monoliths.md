> 자료주소 : https://github.com/arawn/building-modular-monoliths-using-spring  

# 우아한 모노리스

## 기술부채

공유된 데이터원본(하나의 Table) 여러개 서비스가 사용하는 상황  
데이터를 일고 조작하는 서비스가 여러군대에 존재  
하나의 기능을 수행하기 위해 동작하는 기능이 복잡해 진다.  
요청 받은 서비스가 해결을 못해 다른 서비스에 위임을 하며 처리 절차가 점진적으로 복잡해진다. (이유는 코드(기능)이 분산이 되어 발생)  
이럴때 요구사항을 빠르게 반영하기 어렵다. 기능을 우선적으로 분산해야 하기 때문에 이렇다 보니 요구사항을 반영하는데 오래 걸릴 수 있다.  
또한 코드가 분산되어있어 여러 서비스에 배포가 같이 이루어져야 한다. 하나가 먼저 배포가되어 반영이 되면 서비스가 무너진다.  

이러한 문제가 발생했던 이유는 원래의 하나의 서비스를 억지로 분산하여 MSA구조로 변경 했던 것이다.  

개발팀 인력의 부족으로 분산된 서비스를 여러개를 맡아 수행될 때 요구사항 접수 후 빠른 데드라인에 개발을 하게 될때 기술부채가 가속화 된다.

이러한 이유 들 때문에 마이크로서비스에서 모노리틱으로 갈아탔다.  
갈아탄 이유 중 하나가 서비스가 장애 직전까지 갈 정도로 불안한 요소가 있었다. 

#### 병합 과정
1. 프로젝트별 구조정리
2. 저장소 및 프로젝트 통합
    1. 새 출발
    2. git 저장소끼리 merge (과거 히스토리 유지하기 위해)
        1. 의존성 정의도 필요하다.
3. 패키지 구조 표준화
4. 서비스 통합
    1. 하나의 애플리케이션에 여러개의 컨텍스트를(자식과 형제로) 갖을 수 있다. (오늘 세미나의 핵심)


#### 모노리틱 단점
1. 예상치 못한 결합
2. 늦은 출시 싸이클
3. 높은 테스트비용
4. 부족한 장애 내성
5. 단일 확장성

단일 코드베이스 이기때문에 그렇다.  
확장은 인스턴스의 수평적인 확장이다. (똑같은 소스베이스가 증대 - 현재 지금과 같다.)

#### 마이크로서비스 장점
1. 조직 부합성
2. 확장성
3. 회복성
    - 장애 대응
4. 배포용이성
5. 대체 가능성
6. 조합성
7. 기술 이기종성

응집과 결합을 다스리는 것이 먼저다. 

### 모듈형 모노리스 참고 자료

업체 : Spring one  
제목 : Refactoring to a system of systems  
인물 : oliver drotbohm  

업체 : GOTO conferences
제목 : modular monoliths  
인물 : simon brown  

업체 : shopify  
제목 : deconstructiong the monoliths  
인물 : kirsten westeinde
 



작은 기능 단위로 나누고 서로 협업할 수 있는 구조로 만들 수 있다면 구조 개선이 많이 된다.  
내부는 숨기고 외부와 통신할때는 곡개된 API를 통해 통신해야 한다.  

모둘과 함게 고민해야하는 부분은 소프트웨어 아키텍츠와 같이 고민해야 한다.  


## 소스
Domin bounded context를 참고  

#### 클래스의 역할이나 성격에 따라 계층 구조로 모듈화를 해라 
단, 시스템이 커질 수 록 계층 구조의 복잡도가 올라 간다.  

Domain 기능으로 구조를 잡으면 독립적일 수 있다.

#### 관심사에 따른 모듈화
1. 수직적 관심사
    1. 비즈니스와 으용 ㅡ프로그램에 특화된 기능
    2. 비지니스 로직을 구현하로 개선할 수 있는지.

2. 수평적 관심사
    1. 재사용성, 범용적이 우선적

2개의 관심사를 섞으면 안된다.

#### 의존성 관리로 느슨하게 결환된 모듈 설계하기

ModularMonolithsApplication


## 참고
- 의존성, 결합, 협력에 관한 자료 : 우아한 객체지향 세미나 or 조영호 (오브젝트)


